<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2314b8a6'%3e%3cpath d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z'/%3e%3c/svg%3e">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>EduSphere AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css" integrity="sha384-sN স্বীকB3AcNonNMW+L+isQrqDTHtouwmbP1zDCvJ+yVEB1OAQGrAgLf8YVNTI6E8" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js" integrity="sha384-hIoD/yV7VbO1Broldu+OFjGsbxfYthV3SYyn1c0wLqM/2SEh0SAOF8aL2z7Kk6sC" crossorigin="anonymous"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'primary': '#14b8a6', // Teal 500
              'primary-focus': '#0d9488', // Teal 600
              'secondary': '#f0f9ff', // Sky 50
              'base-100': '#ffffff',
              'base-200': '#f0f2f5',
              'base-300': '#e2e8f0',
              'text-primary': '#1f2937',
              'text-secondary': '#4b5563',
            },
          }
        }
      }
    </script>
</head>
<body class="bg-base-200">
    <div id="root"></div>

    <script type="module">
        // --- CDN IMPORTS ---
        import React, { useState, useCallback, useEffect, useMemo, useRef } from 'https://esm.sh/react@19.1.0';
        import ReactDOM from 'https://esm.sh/react-dom@19.1.0/client';
        import { GoogleGenAI } from 'https://esm.sh/@google/genai@1.8.0';

        // --- CONFIG ---
        // IMPORTANT: Paste your Gemini API Key here. I've left it as you asked.
        const GEMINI_API_KEY = "AIzaSyBUzFJAEzz52zBXx-NNQvRbbeAGXJEOpbE";

        // --- GLOBAL SCOPE VARIABLES (replaces types.ts) ---
        const AppMode = {
            TUTOR: 'TUTOR',
            QUIZ: 'QUIZ',
            GEOGUESSER: 'GEOGUESSER',
        };

        // --- START OF FILE constants.tsx ---
        const UI_TEXTS = {
            en: {
                headerTitle: 'EduSphere AI',
                sourcesTitle: 'Sources:',
                chatInputHint: 'Press Ctrl+Enter to send',
                attachImageLabel: 'Attach image',
                takePhotoLabel: 'Take photo',
                welcomeMessage: {
                    id: 'welcome-message-en',
                    sender: 'ai',
                    text: `
Hello! I'm **EduSphere AI**, your friendly study assistant. I'm here to help you learn and have fun.

You can switch between my functions using the buttons above:
- 📚 **Tutor Mode**: Ask me anything! I can explain concepts, solve problems step-by-step, and find the latest information for you.
- 📝 **Quiz Mode**: Want to test your knowledge? Just tell me the topic, for example: "Quiz me on the solar system".
- 🌍 **GeoGuesser Game**: Let's play a game! I'll describe a place, and you guess where it is.

What would you like to do first?`,
                },
                modeInfo: {
                    [AppMode.TUTOR]: { emoji: '📚', title: 'Tutor Mode', placeholder: 'Ask me anything about any subject...' },
                    [AppMode.QUIZ]: { emoji: '📝', title: 'Quiz Mode', placeholder: 'e.g., "Give me a 5-question quiz on ancient Rome"' },
                    [AppMode.GEOGUESSER]: { emoji: '🌍', title: 'GeoGuesser Game', placeholder: 'Type "start" for a new location, or guess!' },
                },
                geoGuesser: {
                    newLocation: "New Location!",
                    scenePrompt: "Here is your scene:",
                    whereAreYou: "Where in the world do you think you are?",
                    startGameFirst: 'Please start a new game by typing "start" first!',
                    oops: "😥 Oops! Something went wrong."
                }
            },
            ru: {
                headerTitle: 'EduSphere AI',
                sourcesTitle: 'Источники:',
                chatInputHint: 'Нажмите Ctrl+Enter для отправки',
                attachImageLabel: 'Прикрепить изображение',
                takePhotoLabel: 'Сделать фото',
                welcomeMessage: {
                    id: 'welcome-message-ru',
                    sender: 'ai',
                    text: `
Привет! Я **EduSphere AI**, ваш дружелюбный помощник в учебе. Я здесь, чтобы помочь вам учиться и веселиться.

Вы можете переключаться между моими функциями с помощью кнопок выше:
- 📚 **Режим Репетитора**: Спрашивайте что угодно! Я могу объяснять концепции, решать задачи шаг за шагом и находить самую свежую информацию.
- 📝 **Режим Викторины**: Хотите проверить свои знания? Просто назовите мне тему, например: "Устрой мне викторину о Солнечной системе".
- 🌍 **Игра GeoGuesser**: Давайте сыграем! Я опишу место, а вы угадаете, где оно находится.

С чего бы вы хотели начать?`,
                },
                modeInfo: {
                    [AppMode.TUTOR]: { emoji: '📚', title: 'Режим Репетитора', placeholder: 'Спросите меня о чем угодно...' },
                    [AppMode.QUIZ]: { emoji: '📝', title: 'Режим Викторины', placeholder: 'например, "Викторина на 5 вопросов о Древнем Риме"' },
                    [AppMode.GEOGUESSER]: { emoji: '🌍', title: 'Игра GeoGuesser', placeholder: 'Напишите "старт" для нового места или угадайте!' },
                },
                geoGuesser: {
                    newLocation: "Новая локация!",
                    scenePrompt: "Вот ваша сцена:",
                    whereAreYou: "Как вы думаете, где в мире вы находитесь?",
                    startGameFirst: 'Пожалуйста, начните новую игру, набрав "старт"!',
                    oops: "😥 Ой! Что-то пошло не так."
                }
            },
        };

        // --- START OF FILE services/geminiService.ts ---
        let ai;
        if (GEMINI_API_KEY && GEMINI_API_KEY !== "PASTE_YOUR_GEMINI_API_KEY_HERE") {
             ai = new GoogleGenAI({ apiKey: GEMINI_API_KEY });
        }
        
        const LANG_MAP = { en: 'English', ru: 'Russian' };
        const getLanguageInstruction = (language) => `You MUST respond in ${LANG_MAP[language]}.`;

        async function* getTutorResponseStream(prompt, history, language, image) {
            const systemInstruction = `You are "EduSphere AI", a friendly and versatile study assistant. 
                - Your goal is to provide clear, accurate, and encouraging explanations.
                - If an image is provided, analyze it as the primary context for the user's question.
                - For problems (math, physics, etc.), including those in images, provide a step-by-step solution. Render all mathematical formulas and expressions using KaTeX syntax (e.g., $$E=mc^2$$ for block, $ax^2+bx+c=0$ for inline).
                - Use web access for current information via Google Search.
                - Present responses in a structured and easy-to-read format using markdown-like syntax (**bold**, - list item, --- for dividers, \`\`\` for code blocks).
                - Always be encouraging and positive.
                - Your persona is 📚. Start every response with this emoji.
                - ${getLanguageInstruction(language)}`;
            const textPart = { text: `Previous conversation: ${history.map(m => `${m.sender}: ${m.text}`).join('\n')}\n\nNew question: ${prompt}` };
            const contents = { parts: [textPart] };
            if (image) {
                const imagePart = { inlineData: { mimeType: image.mimeType, data: image.data } };
                contents.parts.unshift(imagePart);
            }
            const responseStream = await ai.models.generateContentStream({
                model: "gemini-2.5-flash-preview-04-17", contents, config: { systemInstruction, tools: [{ googleSearch: {} }] },
            });
            for await (const chunk of responseStream) {
                const sources = chunk.candidates?.[0]?.groundingMetadata?.groundingChunks?.map((chunk) => chunk.web).filter(Boolean);
                yield { textChunk: chunk.text, sources: sources?.length ? sources : undefined };
            }
        }

        async function* generateQuizStream(prompt, language) {
            const systemInstruction = `You are "EduSphere AI" in Quiz Master mode.
                - When a user asks for a quiz on a topic, generate a short, multiple-choice quiz (3-5 questions).
                - Clearly label the questions and options.
                - Instruct the user to answer all questions at once.
                - When the user submits their answers, evaluate them, provide the correct answers, a score, and brief explanations.
                - Your persona is 📝. Start every response with this emoji.
                - ${getLanguageInstruction(language)}`;
            const responseStream = await ai.models.generateContentStream({
                model: "gemini-2.5-flash-preview-04-17", contents: prompt, config: { systemInstruction }
            });
            for await (const chunk of responseStream) {
                yield { textChunk: chunk.text };
            }
        }

        const getGeoGuesserScene = async (language) => {
            const prompt = `
            Generate a single JSON object with three keys: "description", "location", and "funFact".
            - "description": Write a detailed, panoramic, and evocative description of a famous, recognizable location anywhere in the world. Do NOT mention the name of the city, country, or any specific landmarks that give it away too easily. Focus on the atmosphere, architecture style, surrounding nature, and what a person might see, hear, or feel. The description should be 2-4 sentences long.
            - "location": A string with the name of the city and country, e.g., "Paris, France".
            - "funFact": A short, interesting "Did you know?" style fun fact about the location.
            - The "description" and "funFact" MUST be in ${LANG_MAP[language]}.`;
            const response = await ai.models.generateContent({
                model: "gemini-2.5-flash-preview-04-17", contents: prompt, config: { responseMimeType: "application/json" },
            });
            let jsonStr = response.text.trim();
            const fenceRegex = /^```(\w*)?\s*\n?(.*?)\n?\s*```$/s;
            const match = jsonStr.match(fenceRegex);
            if (match && match[2]) { jsonStr = match[2].trim(); }
            try {
                return JSON.parse(jsonStr);
            } catch (e) {
                console.error("Failed to parse GeoGuesser JSON response:", e, "Raw text:", jsonStr);
                throw new Error(`Could not generate a new location. Please try again. The content should be in ${LANG_MAP[language]}.`);
            }
        };

        const evaluateGeoGuesserAnswer = async (userGuess, correctLocation, funFact, language) => {
            const prompt = `The user is playing a location guessing game.
            - The correct location is: "${correctLocation}"
            - The user's guess is: "${userGuess}"
            Your task is to evaluate if the guess is correct. The guess is correct if it contains the city or country name. Be lenient.
            Respond in the following format ONLY, and the entire response must be in ${LANG_MAP[language]}:
            - If correct, start with the localized equivalent of "Correct! 🎉". Then, on a new line, reveal the location. On another new line, share the fun fact starting with the localized equivalent of "💡 Fun Fact:".
            - If incorrect, start with the localized equivalent of "Not quite! 🤔". Then, on a new line, reveal the correct location. On another new line, share the fun fact starting with the localized equivalent of "💡 Fun Fact:".
            - The fun fact you must use is: "${funFact}"`;
            const response = await ai.models.generateContent({
                model: "gemini-2.5-flash-preview-04-17", contents: prompt, config: { thinkingConfig: { thinkingBudget: 0 } }
            });
            return `🌍 ${response.text}`;
        };

        // --- START OF FILE components/icons.tsx ---
        const EduSphereIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor" }, React.createElement("path", { d: "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z" }));
        const BotIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M12 8V4H8" }), React.createElement("rect", { width: "16", height: "12", x: "4", y: "8", rx: "2" }), React.createElement("path", { d: "M2 14h2" }), React.createElement("path", { d: "M20 14h2" }), React.createElement("path", { d: "M15 13v2" }), React.createElement("path", { d: "M9 13v2" }));
        const UserIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2" }), React.createElement("circle", { cx: "12", cy: "7", r: "4" }));
        const SendIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "m22 2-7 20-4-9-9-4Z" }), React.createElement("path", { d: "M22 2 11 13" }));
        const LinkIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.72" }), React.createElement("path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.72-1.72" }));
        const PaperclipIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "m21.44 11.05-9.19 9.19a6 6 0 0 1-8.49-8.49l8.57-8.57A4 4 0 1 1 18 8.84l-8.59 8.59a2 2 0 0 1-2.83-2.83l8.49-8.48" }));
        const XIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M18 6 6 18" }), React.createElement("path", { d: "m6 6 12 12" }));
        const CameraIcon = ({ className }) => React.createElement("svg", { className, xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("path", { d: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z" }), React.createElement("circle", { cx: "12", cy: "13", r: "3" }));

        // --- START OF FILE components/MessageFormatter.tsx ---
        const CodeBlock = ({ code }) => {
            const [lang, ...codeLines] = code.split('\n');
            const language = lang.match(/^[a-z]+$/) ? lang : '';
            const codeContent = language ? codeLines.join('\n') : code;
            return React.createElement("div", { className: "my-2 bg-gray-800 rounded-lg overflow-hidden" },
                language && React.createElement("div", { className: "text-xs text-gray-400 px-4 py-1 bg-gray-900" }, language),
                React.createElement("pre", { className: "p-4 overflow-x-auto text-white" },
                    React.createElement("code", { className: "font-mono text-sm" }, codeContent)
                )
            );
        };
        const MessageFormatter = ({ text }) => {
            const formattedNodes = useMemo(() => {
                if (!text) return [];
                const parts = text.split(/(```[\s\S]*?```|`[^`]*?`|\$\$[\s\S]*?\$\$|\$[^$]*?\$|\*\*.*?\*\*|\n)/g);
                return parts.map((part, index) => {
                    if (!part) return null;
                    if (part === '\n') return React.createElement("br", { key: index });
                    if (part.startsWith('**') && part.endsWith('**')) return React.createElement("strong", { key: index }, part.substring(2, part.length - 2));
                    if (part.startsWith('```') && part.endsWith('```')) {
                        const code = part.substring(3, part.length - 3).trim();
                        return React.createElement(CodeBlock, { key: index, code: code });
                    }
                    if (part.startsWith('`') && part.endsWith('`')) return React.createElement("code", { key: index, className: "bg-gray-200 text-gray-800 rounded px-1 py-0.5 font-mono text-sm mx-1" }, part.substring(1, part.length - 1));
                    if (part.startsWith('$$') && part.endsWith('$$')) {
                        const latex = part.substring(2, part.length - 2);
                        try {
                            if (window.katex) {
                                const html = window.katex.renderToString(latex, { throwOnError: false, displayMode: true });
                                return React.createElement("div", { key: index, dangerouslySetInnerHTML: { __html: html }, className: "my-2 overflow-x-auto" });
                            }
                        } catch (e) { console.error("Katex rendering error:", e); }
                        return React.createElement("span", { key: index }, part);
                    }
                    if (part.startsWith('$') && part.endsWith('$')) {
                        const latex = part.substring(1, part.length - 1);
                        try {
                            if (window.katex) {
                                const html = window.katex.renderToString(latex, { throwOnError: false, displayMode: false });
                                return React.createElement("span", { key: index, dangerouslySetInnerHTML: { __html: html } });
                            }
                        } catch (e) { console.error("Katex rendering error:", e); }
                        return React.createElement("span", { key: index }, part);
                    }
                    const listMatch = part.match(/^(\s*[-*+]\s+)(.*)/);
                    if (listMatch) {
                        return React.createElement("div", { key: index, className: "flex flex-row" },
                            React.createElement("span", { className: "mr-2" }, listMatch[1].trim()),
                            React.createElement("span", null, listMatch[2])
                        );
                    }
                    if (part.startsWith('---')) return React.createElement("hr", { key: index, className: "my-4 border-base-300" });
                    return React.createElement("span", { key: index }, part);
                });
            }, [text]);
            return React.createElement(React.Fragment, null, formattedNodes);
        };

        // --- START OF FILE components/CameraModal.tsx ---
        const CameraModal = ({ isOpen, onClose, onPhotoTaken, lang }) => {
            const videoRef = useRef(null);
            const canvasRef = useRef(null);
            const [stream, setStream] = useState(null);
            const [error, setError] = useState(null);
            const MODAL_TEXT = {
                en: { title: "Take a Photo", permissionError: "Camera access was denied. Please enable it in your browser settings to continue.", genericError: "Could not access the camera. Please make sure it is not being used by another application.", capture: "Snap Photo", cancel: "Cancel" },
                ru: { title: "Сделать фото", permissionError: "Доступ к камере запрещен. Пожалуйста, включите его в настройках вашего браузера, чтобы продолжить.", genericError: "Не удалось получить доступ к камере. Убедитесь, что она не используется другим приложением.", capture: "Сфотографировать", cancel: "Отмена" }
            };
            const text = MODAL_TEXT[lang];

            const stopStream = useCallback(() => {
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    setStream(null);
                }
            }, [stream]);

            useEffect(() => {
                if (isOpen) {
                    setError(null);
                    navigator.mediaDevices.getUserMedia({ video: true })
                        .then(s => {
                            setStream(s);
                            if (videoRef.current) videoRef.current.srcObject = s;
                        })
                        .catch(err => {
                            console.error("Camera Error:", err);
                            if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') setError(text.permissionError);
                            else setError(text.genericError);
                        });
                } else {
                    stopStream();
                }
                return () => stopStream();
            }, [isOpen, stopStream, text.genericError, text.permissionError]);

            const handleCapture = () => {
                if (videoRef.current && canvasRef.current) {
                    const video = videoRef.current;
                    const canvas = canvasRef.current;
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const context = canvas.getContext('2d');
                    if (context) {
                        context.drawImage(video, 0, 0, canvas.width, canvas.height);
                        canvas.toBlob(blob => {
                            if (blob) {
                                const file = new File([blob], `photo-${Date.now()}.jpg`, { type: 'image/jpeg' });
                                onPhotoTaken(file);
                                handleClose();
                            }
                        }, 'image/jpeg');
                    }
                }
            };

            const handleClose = () => {
                stopStream();
                onClose();
            };

            if (!isOpen) return null;

            return React.createElement("div", { className: "fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 transition-opacity", "aria-modal": "true", role: "dialog" },
                React.createElement("div", { className: "bg-base-100 rounded-2xl shadow-xl w-full max-w-2xl m-4 transform transition-all flex flex-col max-h-[90vh]" },
                    React.createElement("div", { className: "flex justify-between items-center p-4 border-b border-base-200 flex-shrink-0" },
                        React.createElement("h3", { className: "text-xl font-semibold text-text-primary" }, text.title),
                        React.createElement("button", { onClick: handleClose, className: "text-text-secondary hover:text-text-primary" }, React.createElement(XIcon, { className: "w-6 h-6" }))
                    ),
                    React.createElement("div", { className: "p-4 flex-grow overflow-hidden" },
                        React.createElement("div", { className: "relative aspect-video bg-black rounded-lg overflow-hidden h-full" },
                            React.createElement("video", { ref: videoRef, autoPlay: true, playsInline: true, className: "w-full h-full object-cover" }),
                            error && React.createElement("div", { className: "absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 p-4" }, React.createElement("p", { className: "text-white text-center" }, error)),
                            !stream && !error && React.createElement("div", { className: "absolute inset-0 flex items-center justify-center bg-black" }, React.createElement("p", { className: "text-white text-center" }, "Starting camera..."))
                        )
                    ),
                    React.createElement("div", { className: "flex justify-end items-center p-4 space-x-3 border-t border-base-200 flex-shrink-0" },
                        React.createElement("button", { onClick: handleClose, className: "px-4 py-2 rounded-lg text-text-secondary hover:bg-base-200 transition-colors" }, text.cancel),
                        React.createElement("button", { onClick: handleCapture, disabled: !stream || !!error, className: "px-6 py-2 bg-primary text-white rounded-lg font-semibold flex items-center space-x-2 hover:bg-primary-focus disabled:bg-base-300 disabled:cursor-not-allowed transition-colors" },
                            React.createElement(CameraIcon, { className: "w-5 h-5" }),
                            React.createElement("span", null, text.capture)
                        )
                    ),
                    React.createElement("canvas", { ref: canvasRef, className: "hidden" })
                )
            );
        };
        
        // --- START OF FILE components/Header.tsx ---
        const Header = ({ title, language, onLanguageChange }) => {
            return React.createElement("header", { className: "w-full bg-base-100/80 backdrop-blur-sm sticky top-0 z-10 flex-shrink-0" },
                React.createElement("div", { className: "max-w-4xl mx-auto px-4 py-3" },
                    React.createElement("div", { className: "flex items-center justify-between" },
                        React.createElement("div", { className: "flex items-center space-x-3" },
                            React.createElement(EduSphereIcon, { className: "h-8 w-8 text-primary" }),
                            React.createElement("h1", { className: "text-2xl font-bold text-text-primary tracking-tight" }, title)
                        ),
                        React.createElement("div", { className: "flex items-center space-x-1 bg-base-200 p-1 rounded-full" },
                            React.createElement("button", { onClick: () => onLanguageChange('en'), className: `px-3 py-1 text-sm font-semibold rounded-full transition-colors duration-200 ${language === 'en' ? 'bg-primary text-white shadow' : 'text-text-secondary hover:bg-base-300'}`, "aria-label": "Switch to English" }, "EN"),
                            React.createElement("button", { onClick: () => onLanguageChange('ru'), className: `px-3 py-1 text-sm font-semibold rounded-full transition-colors duration-200 ${language === 'ru' ? 'bg-primary text-white shadow' : 'text-text-secondary hover:bg-base-300'}`, "aria-label": "Switch to Russian" }, "RU")
                        )
                    )
                )
            );
        };
        
        // --- START OF FILE components/ChatWindow.tsx ---
        const LoadingSpinner = () => React.createElement("div", { className: "flex items-center space-x-2" }, React.createElement("div", { className: "h-2.5 w-2.5 bg-primary rounded-full animate-bounce [animation-delay:-0.3s]" }), React.createElement("div", { className: "h-2.5 w-2.5 bg-primary rounded-full animate-bounce [animation-delay:-0.15s]" }), React.createElement("div", { className: "h-2.5 w-2.5 bg-primary rounded-full animate-bounce" }));
        const SourceLink = ({ source }) => React.createElement("a", { href: source.uri, target: "_blank", rel: "noopener noreferrer", className: "inline-flex items-center bg-teal-50 hover:bg-teal-100 text-teal-700 text-xs font-medium px-2.5 py-1 rounded-full transition-colors duration-200" }, React.createElement(LinkIcon, { className: "w-3 h-3 mr-1.5" }), source.title || new URL(source.uri).hostname);
        const Message = ({ message, sourcesTitle }) => {
            const isUser = message.sender === 'user';
            return React.createElement("div", { className: `flex items-start gap-3 my-4 ${isUser ? 'flex-row-reverse' : 'flex-row'}` },
                React.createElement("div", { className: `flex-shrink-0 h-10 w-10 rounded-full flex items-center justify-center ${isUser ? 'bg-primary' : 'bg-base-300'}` }, isUser ? React.createElement(UserIcon, { className: "h-6 w-6 text-white" }) : React.createElement(BotIcon, { className: "h-6 w-6 text-text-primary" })),
                React.createElement("div", { className: `p-4 rounded-xl max-w-lg prose ${isUser ? 'bg-primary text-white prose-invert' : 'bg-base-100 text-text-primary shadow-sm'}` },
                    message.imageUrl && React.createElement("img", { src: message.imageUrl, alt: "User upload", className: "rounded-lg mb-2 max-w-full h-auto" }),
                    message.text && React.createElement(MessageFormatter, { text: message.text }),
                    message.sources && message.sources.length > 0 && React.createElement("div", { className: "mt-4 pt-3 border-t border-t-base-300/50" },
                        React.createElement("h4", { className: "text-xs font-semibold mb-2 text-text-secondary not-prose" }, sourcesTitle),
                        React.createElement("div", { className: "flex flex-wrap gap-2 not-prose" }, message.sources.map((source, index) => React.createElement(SourceLink, { key: index, source: source })))
                    )
                )
            );
        };
        const ChatWindow = ({ messages, isLoading, onSendMessage, placeholder, error, sourcesTitle, chatInputHint, currentMode, language, attachImageLabel, takePhotoLabel }) => {
            const [inputText, setInputText] = useState('');
            const [selectedImage, setSelectedImage] = useState(null);
            const [isCameraOpen, setIsCameraOpen] = useState(false);
            const messagesEndRef = useRef(null);
            const textareaRef = useRef(null);
            const fileInputRef = useRef(null);
            useEffect(() => { messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' }); }, [messages, isLoading]);
            useEffect(() => { if (currentMode !== AppMode.TUTOR) setSelectedImage(null); }, [currentMode]);
            const handleFormSubmit = (e) => {
                e.preventDefault();
                if (inputText.trim() || selectedImage) {
                    onSendMessage(inputText, selectedImage);
                    setInputText('');
                    setSelectedImage(null);
                    if (textareaRef.current) textareaRef.current.style.height = 'auto';
                }
            };
            const handleKeyDown = (e) => { if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { e.preventDefault(); handleFormSubmit(e); } };
            const handleInputChange = (e) => { setInputText(e.target.value); e.target.style.height = 'auto'; e.target.style.height = `${e.target.scrollHeight}px`; };
            const handleImageSelect = (e) => { if (e.target.files && e.target.files[0]) setSelectedImage(e.target.files[0]); };
            const handlePhotoTaken = (file) => { setSelectedImage(file); setIsCameraOpen(false); };
            return React.createElement("div", { className: "bg-base-100 rounded-xl shadow-lg flex flex-col h-full" },
                error && React.createElement("div", { className: "p-3 bg-red-100 text-red-700 text-sm rounded-t-xl" }, error),
                React.createElement("div", { className: "flex-grow p-4 overflow-y-auto" },
                    messages.map((msg) => React.createElement(Message, { key: msg.id, message: msg, sourcesTitle: sourcesTitle })),
                    isLoading && messages[messages.length - 1]?.sender !== 'ai' && React.createElement("div", { className: "flex items-start gap-3 my-4 flex-row" },
                        React.createElement("div", { className: "flex-shrink-0 h-10 w-10 rounded-full flex items-center justify-center bg-base-300" }, React.createElement(BotIcon, { className: "h-6 w-6 text-text-primary" })),
                        React.createElement("div", { className: "p-4 rounded-xl bg-base-100 text-text-primary shadow-sm" }, React.createElement(LoadingSpinner, null))
                    ),
                    React.createElement("div", { ref: messagesEndRef })
                ),
                React.createElement("div", { className: "p-4 border-t border-base-200 flex-shrink-0" },
                    selectedImage && React.createElement("div", { className: "mb-3 relative w-24 h-24 p-2 border border-base-300 rounded-lg" },
                        React.createElement("img", { src: URL.createObjectURL(selectedImage), alt: "Selected preview", className: "w-full h-full object-cover rounded" }),
                        React.createElement("button", { onClick: () => setSelectedImage(null), className: "absolute -top-2 -right-2 bg-gray-700 text-white rounded-full p-0.5 hover:bg-gray-900 transition-colors", "aria-label": "Remove image" }, React.createElement(XIcon, { className: "w-4 h-4" }))
                    ),
                    React.createElement("form", { onSubmit: handleFormSubmit, className: "flex items-end space-x-3" },
                        currentMode === AppMode.TUTOR && React.createElement(React.Fragment, null,
                            React.createElement("input", { type: "file", ref: fileInputRef, onChange: handleImageSelect, accept: "image/*", className: "hidden" }),
                            React.createElement("button", { type: "button", onClick: () => fileInputRef.current?.click(), disabled: isLoading, className: "flex-shrink-0 w-12 h-12 bg-base-200 text-text-secondary rounded-full flex items-center justify-center hover:bg-base-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary transition-all duration-200 disabled:opacity-50", "aria-label": attachImageLabel }, React.createElement(PaperclipIcon, { className: "h-6 w-6" })),
                            React.createElement("button", { type: "button", onClick: () => setIsCameraOpen(true), disabled: isLoading, className: "flex-shrink-0 w-12 h-12 bg-base-200 text-text-secondary rounded-full flex items-center justify-center hover:bg-base-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary transition-all duration-200 disabled:opacity-50", "aria-label": takePhotoLabel }, React.createElement(CameraIcon, { className: "h-6 w-6" }))
                        ),
                        React.createElement("textarea", { ref: textareaRef, rows: 1, value: inputText, onChange: handleInputChange, onKeyDown: handleKeyDown, placeholder: placeholder, disabled: isLoading, className: "flex-grow p-3 border border-base-300 rounded-2xl focus:outline-none focus:ring-2 focus:ring-primary transition-shadow duration-200 disabled:opacity-50 resize-none overflow-y-auto max-h-40 bg-base-200", style: { lineHeight: '1.5rem' } }),
                        React.createElement("button", { type: "submit", disabled: isLoading || (!inputText.trim() && !selectedImage), className: "flex-shrink-0 w-12 h-12 bg-primary text-white rounded-full flex items-center justify-center hover:bg-primary-focus focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary transition-all duration-200 disabled:bg-base-300 disabled:cursor-not-allowed" }, React.createElement(SendIcon, { className: "h-6 w-6" }))
                    ),
                    React.createElement("p", { className: "text-xs text-text-secondary text-center mt-2 px-4" }, chatInputHint)
                ),
                React.createElement(CameraModal, { isOpen: isCameraOpen, onClose: () => setIsCameraOpen(false), onPhotoTaken: handlePhotoTaken, lang: language })
            );
        };
        
        // --- START OF FILE App.tsx ---
        const App = () => {
            const [language, setLanguage] = useState('en');
            const uiTexts = useMemo(() => UI_TEXTS[language], [language]);
            const [mode, setMode] = useState(AppMode.TUTOR);
            const [messages, setMessages] = useState([uiTexts.welcomeMessage]);
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);
            const [currentGeoGuesser, setCurrentGeoGuesser] = useState(null);
            const fileToBase64 = (file) => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                reader.onload = () => resolve(reader.result.split(',')[1]);
                reader.onerror = error => reject(error);
            });
            useEffect(() => {
                if (!GEMINI_API_KEY || GEMINI_API_KEY === "PASTE_YOUR_GEMINI_API_KEY_HERE") {
                    setError("GEMINI_API_KEY is not set. Please add it to the script to use the app.");
                    setIsLoading(false);
                }
            }, []);
            useEffect(() => { setMessages([uiTexts.welcomeMessage]); setCurrentGeoGuesser(null); setError(null); }, [language, uiTexts.welcomeMessage]);
            const handleModeChange = (newMode) => { setMode(newMode); setMessages([uiTexts.welcomeMessage]); setCurrentGeoGuesser(null); setError(null); };
            const handleLanguageChange = (newLang) => { if (newLang !== language) setLanguage(newLang); };
            const handleSendMessage = useCallback(async (inputText, imageFile) => {
                if (isLoading || (!inputText.trim() && !imageFile)) return;
                setIsLoading(true);
                setError(null);
                const userMessage = { id: Date.now().toString(), sender: 'user', text: inputText, imageUrl: imageFile ? URL.createObjectURL(imageFile) : undefined };
                setMessages(prev => [...prev, userMessage]);
                try {
                    if (mode === AppMode.TUTOR) {
                        const image = imageFile ? { mimeType: imageFile.type, data: await fileToBase64(imageFile) } : null;
                        const aiMessageId = `ai-${Date.now()}`;
                        setMessages(prev => [...prev, { id: aiMessageId, sender: 'ai', text: '' }]);
                        const stream = getTutorResponseStream(inputText, messages, language, image);
                        for await (const chunk of stream) {
                            setMessages(prev => prev.map(msg => msg.id === aiMessageId ? { ...msg, text: msg.text + (chunk.textChunk || ''), sources: chunk.sources ? chunk.sources : msg.sources, } : msg));
                        }
                    } else if (mode === AppMode.QUIZ) {
                        const aiMessageId = `ai-${Date.now()}`;
                        setMessages(prev => [...prev, { id: aiMessageId, sender: 'ai', text: '' }]);
                        const stream = generateQuizStream(inputText, language);
                        for await (const chunk of stream) {
                            setMessages(prev => prev.map(msg => msg.id === aiMessageId ? { ...msg, text: msg.text + chunk.textChunk } : msg));
                        }
                    } else if (mode === AppMode.GEOGUESSER) {
                        let responseText = '';
                        if (inputText.trim().toLowerCase() === 'start' || inputText.trim().toLowerCase() === 'старт') {
                            const geoData = await getGeoGuesserScene(language);
                            setCurrentGeoGuesser(geoData);
                            responseText = `🌍 **${uiTexts.geoGuesser.newLocation}** ${uiTexts.geoGuesser.scenePrompt}\n\n${geoData.description}\n\n${uiTexts.geoGuesser.whereAreYou}`;
                        } else {
                            if (!currentGeoGuesser) {
                                responseText = uiTexts.geoGuesser.startGameFirst;
                            } else {
                                responseText = await evaluateGeoGuesserAnswer(inputText, currentGeoGuesser.location, currentGeoGuesser.funFact, language);
                                setCurrentGeoGuesser(null); // Reset after guess
                            }
                        }
                        setMessages(prev => [...prev, { id: Date.now().toString(), sender: 'ai', text: responseText }]);
                    }
                } catch (e) {
                    console.error(e);
                    const errorMessage = e instanceof Error ? e.message : 'An unknown error occurred.';
                    setMessages(prev => [...prev, { id: Date.now().toString(), sender: 'ai', text: `${uiTexts.geoGuesser.oops} ${errorMessage}` }]);
                    setError(`Failed to get response. ${errorMessage}`);
                } finally {
                    setIsLoading(false);
                }
            }, [isLoading, mode, messages, currentGeoGuesser, language, uiTexts]);
            const modeInfo = useMemo(() => uiTexts.modeInfo[mode], [mode, uiTexts]);
            return React.createElement("div", { className: "flex flex-col h-screen font-sans bg-base-200 text-text-primary" },
                React.createElement(Header, { title: uiTexts.headerTitle, language: language, onLanguageChange: handleLanguageChange }),
                React.createElement("div", { className: "w-full max-w-4xl mx-auto p-4 flex-shrink-0" },
                    React.createElement("div", { className: "bg-base-100 rounded-xl shadow-md p-2 flex justify-center space-x-2" },
                        Object.keys(AppMode).map((key) => React.createElement("button", { key: key, onClick: () => handleModeChange(AppMode[key]), className: `flex-1 sm:flex-initial sm:px-6 py-3 text-sm sm:text-base font-semibold rounded-lg transition-all duration-200 ease-in-out focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary ${mode === AppMode[key] ? 'bg-primary text-white shadow' : 'bg-transparent text-text-secondary hover:bg-base-200'}` },
                            React.createElement("span", { className: "mr-2" }, uiTexts.modeInfo[AppMode[key]].emoji),
                            uiTexts.modeInfo[AppMode[key]].title
                        ))
                    )
                ),
                React.createElement("main", { className: "flex-grow w-full max-w-4xl mx-auto px-4 pb-4 flex flex-col min-h-0" },
                    React.createElement(ChatWindow, { messages, isLoading, onSendMessage: handleSendMessage, placeholder: modeInfo.placeholder, error, sourcesTitle: uiTexts.sourcesTitle, chatInputHint: uiTexts.chatInputHint, currentMode: mode, language, attachImageLabel: uiTexts.attachImageLabel, takePhotoLabel: uiTexts.takePhotoLabel })
                )
            );
        };
        
        // --- ENTRY POINT (replaces index.tsx) ---
        const rootElement = document.getElementById('root');
        if (!rootElement) {
            throw new Error("Could not find root element to mount to");
        }
        const root = ReactDOM.createRoot(rootElement);
        root.render(React.createElement(React.StrictMode, null, React.createElement(App, null)));

    </script>
</body>
</html>